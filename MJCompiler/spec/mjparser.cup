

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("Sintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, RETURN, PRINT, VOID, CONST, CLASS;
terminal SEMI, COMMA, EQUAL, PLUS;
terminal LPAREN, RPAREN, LBRACE, RBRACE, LSQUARE, RSQUARE;
terminal Integer NUMBER;
terminal String IDENT;
terminal IF, ELSE;
terminal NUM_CONST, CHAR_CONST, BOOL_CONST;
terminal CONTINUE, WHILE, READ, NEW, ENUM, SWITCH, BREAK, EXTENDS, CASE, YIELD, DO;
terminal COLON, GTE, LT, DOT, LTE, DIV, MINUS, MOD, MUL, GT, QUESTION, INC, NEQ, AND, EQ, OR, DEC;

nonterminal Program, DeclarationsList;
nonterminal ConstDecl, ConstDeclList, ConstDeclElem;
nonterminal VarDecl, VarList, Var, VarDeclList;
nonterminal ClassDecl, ClassMethods, Extends;
nonterminal MethodDecls, MethodDecl;
nonterminal FormPars, ActPars, PossibleActPars;
nonterminal StatementList, Statement, CaseList;
nonterminal Type, ExtendedType;
nonterminal Designator, RepeatedDesignator, DesignatorStatement, DesignatorOptions;
nonterminal Assignop, Relop, Addop, Mulop;
nonterminal Term, Terms;
nonterminal Factor, Expr;
nonterminal Condition, IfCondition, CondTerm, CondFact;

precedence nonassoc ELSE;
precedence nonassoc IF;

/* PROGRAM */
Program ::= (Program) PROG IDENT DeclarationsList LBRACE MethodDecls RBRACE
;

DeclarationsList ::= (ConstDeclarationsList) DeclarationsList ConstDecl
				|
				(VarDeclarationsList) DeclarationsList VarDecl
				|
				(ClassDeclarationsList) DeclarationsList ClassDecl
				|
				(NoDecls) /* epsilon */
				;

				
/* CONST DECL */
ConstDecl ::= (ConstDecl) CONST Type ConstDeclList SEMI
;

ConstDeclList ::= (ConstDeclarationList) ConstDeclList COMMA ConstDeclElem
				|
				(OneElemConstDeclList) ConstDeclElem
				;
				
ConstDeclElem ::= (NumConstDecl) IDENT:constName EQUAL NUM_CONST
			|
			(CharConstDecl) IDENT:constName EQUAL CHAR_CONST
			|
			(BoolConstDecl) IDENT:constName EQUAL BOOL_CONST
			;	


/* VAR DECL */
VarDecl ::= (VarDecl) Type:varType VarList SEMI;

VarDeclList ::= (VarDeclarationList) VarDeclList VarDecl
			|
			(NoVarDecls) /* epsilon */
			;

VarList ::= (VariableList) VarList COMMA Var
			|
			(OneElemVarList) Var
			;

Var ::= (ArrayDeclaration) IDENT:varName LSQUARE RSQUARE
		|
		(VarDeclaration) IDENT:varName 
		|
		(ErrorVar) error:e {: parser.report_error("Izvrsen oporavak od greske na linji " + eleft + ", pri deklerisanju globalne promenljive", null); :}
		;

			
/* CLASS DECL */
ClassDecl ::= (ClassDecl) CLASS IDENT:className Extends LBRACE VarDeclList ClassMethods RBRACE
;

Extends ::= (ClassExtends) EXTENDS Type
			|
			(NoExtends)
			;
			
ClassMethods ::= (ClassMethodsList) LBRACE MethodDecls RBRACE
			|
			(NoClassMethods)
			;

/* TYPE */
Type ::= (Type) IDENT:typeName;

ExtendedType ::= (BasicType) Type 
				|
				(VoidType) VOID
				;


/* METHOD DECL */
MethodDecls ::= (MethodDeclList) MethodDecls MethodDecl
			|
			(NoMethodDecls)
			;
			
MethodDecl ::= (MethodDeclWithParms) ExtendedType IDENT LPAREN FormPars RPAREN VarDeclList LBRACE StatementList RBRACE
			|
			(MethodDeclNoParms) ExtendedType IDENT LPAREN RPAREN VarDeclList LBRACE StatementList RBRACE
			;

FormPars ::= (FormParsList) FormPars COMMA Type Var
			|
			(FormParsElem) Type Var
			|
			(FormParsError) error:e {: parser.report_error("Izvrsen oporavak od greske na liniji " + eleft + ", pri deklaraciji formalnog parametra funkcije", null); :}
			;

/* STATEMENTS */ 
StatementList ::= (StmtList) StatementList Statement
			 	| 
			 	(NoStmt) /* epsilon */
			 	;
			 	
Statement ::= (DesignatorStmt) DesignatorStatement /* SEMI moved to DesignatorStmt */
			|
			(IfStmt) IF LPAREN IfCondition RPAREN Statement
			|
			(IfElseStmt) IF LPAREN IfCondition RPAREN Statement ELSE Statement
			|
			(DoWhileStmt) DO Statement WHILE LPAREN Condition RPAREN SEMI
			|
			(YieldStmt) YIELD Expr SEMI
			|
			(BreakStmt) BREAK SEMI
			|
			(ContinueStmt) CONTINUE SEMI
			|
			(ReturnVoid) RETURN SEMI
			|
			(ReturnStmt) RETURN Expr SEMI
			|
			(ReadStmt) READ LPAREN Designator RPAREN SEMI
			|
			(PrintStmt) PRINT LPAREN Expr RPAREN SEMI
			|
			(PrintConstStmt) PRINT LPAREN Expr COMMA NUM_CONST RPAREN SEMI
			|
			(MoreStmts) LBRACE StatementList RBRACE
			;
			
/* EXPR */
Expr ::= (BasicTerms) Terms
		|
		(NegTerms) MINUS Terms
		|
		(SwitchExpr) SWITCH LPAREN Expr RPAREN LBRACE CaseList RBRACE
		;
					
CaseList ::= (Cases) CaseList CASE NUM_CONST COLON StatementList
			|
			(NoCase) /* epsilon */
			;
		
/* TERM */
Terms ::= (TermList) Terms Addop Term
		|
		(OneTerm) Term
		;
		
Term ::= (FactorList) Term Mulop Factor
		|
		(OneFactor) Factor
		;
		
/* FACTOR */
Factor ::= (DesignatorFactor) Designator
		|
		(DesignatorFactorActPars) Designator PossibleActPars
		|
		(NumFactor) NUM_CONST
		|
		(CharFactor) CHAR_CONST
		|
		(BoolFactor) BOOL_CONST
		|
		(NewFactor) NEW Type
		|
		(NewFactorArray) NEW Type LSQUARE Expr RSQUARE
		|
		(ExprFactor) LPAREN Expr RPAREN
		;
			
/* DESIGNATOR */
DesignatorStatement ::= (DesignatorStatement) Designator DesignatorOptions
;

DesignatorOptions ::= (BasicExpr) Assignop Expr	SEMI
					|
					(ErrorAssigning) error:e SEMI 
					{: parser.report_error("Izvrsen oporavak od greske na liniji " + eleft + ", kod konstrukcije iskaza dodele", null); :}
					|
					(DesignatorActPars) PossibleActPars SEMI
					|
					(Increase) INC SEMI
					|
					(Decrease) DEC SEMI
					;
		
Designator ::= (DesignatorJustIdent) IDENT
				|
				(DesignatorWithExpr) IDENT LSQUARE Expr RSQUARE
;

					
/* ACT PARS */
ActPars ::= (ActParsList) ActPars COMMA Expr
		|
		(OneExpr) Expr
		;
		
PossibleActPars ::= (WithActPars) LPAREN ActPars RPAREN 
					|
					(WithoutActPars) LPAREN RPAREN 
					;
/* "(" [ActPars] ")" */
		

/* CONDITION */
IfCondition ::= (JustCondition) Condition
			|
			(IfError) error:e {:  parser.report_error("Izvrsen oporavak od greske na liniji " + eleft + ", kod logickog izraza unutar if konstrukcije", null); :}
			;

Condition ::= (CondTerms) Condition OR CondTerm
			|
			(OneCondTerm) CondTerm
			;
			
CondTerm ::= (CondFacts) CondTerm AND CondFact
			|
			(OneCondFact) CondFact
			;
			
CondFact ::= (CondFact1Expr) Expr
			|
			(CondFact2Expr) Expr Relop Expr
			;
			
/* OPERATIONS */
Assignop ::= (Assignop) EQUAL
;

Relop ::= (Equal) EQ 
		|
		(NotEqual) NEQ 
		| 
		(GreaterThen) GT 
		|
		(GreaterThenEqual) GTE 
		|
		(LessThen) LT 
		|
		(LessThenEqual) LTE
;

Addop ::= (Plus) PLUS 
		|
		(Minus) MINUS
;

Mulop ::= (Mul) MUL 
		|
		(Div) DIV 
		|
		(Mod) MOD
;

			