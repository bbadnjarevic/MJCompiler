

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	boolean errorDetected;
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("Sintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}

init with {:
	errorDetected = false;
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG,  PRINT, VOID, CONST, CLASS;
terminal SEMI, COMMA, EQUAL, PLUS;
terminal LPAREN, RPAREN, LBRACE, RBRACE, LSQUARE, RSQUARE;
terminal Integer NUM_CONST;
terminal String CHAR_CONST;
terminal String BOOL_CONST;
terminal String IDENT;
terminal String RETURN;
terminal IF, ELSE;
terminal CONTINUE, WHILE, READ, NEW, ENUM, SWITCH, BREAK, EXTENDS, CASE, YIELD, DEFAULT, DO;
terminal COLON, GTE, LT, DOT, LTE, DIV, MINUS, MOD, MUL, GT, QUESTION, INC, NEQ, AND, EQ, OR, DEC;

nonterminal DeclarationsList;
nonterminal ConstDecl, ConstDeclList, ConstDeclElem;
nonterminal VarDecl, VarList, VarDeclList;
nonterminal ClassDecl, ClassMethods, Extends;
nonterminal MethodDecls;
nonterminal FormPars, ActPars, PossibleActPars;
nonterminal RepeatedDesignator, DesignatorStatement, DesignatorOptions;
nonterminal Assignop, Addop, Mulop;
nonterminal IfCondition;
nonterminal InitDoWhile, InitSwitch;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program, MethodDecl, MethodTypeName, FuncDesignator, Designator, Var, Relop;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Expr, Terms, Term, Factor, Condition, CondTerm, CondFact;
nonterminal rs.etf.pp1.symboltable.concepts.Struct StatementList, Statement, CaseList, DefaultCase;

precedence left ELSE;

/* PROGRAM */
Program ::= (Program) PROG ProgName DeclarationsList LBRACE MethodDecls RBRACE
;

ProgName ::= (ProgName) IDENT:name
;

DeclarationsList ::= (ConstDeclarationsList) DeclarationsList ConstDecl
				|
				(VarDeclarationsList) DeclarationsList VarDecl
				|
				(ClassDeclarationsList) DeclarationsList ClassDecl
				|
				(NoDecls) /* epsilon */
				;

				
/* CONST DECL */
ConstDecl ::= (ConstDecl) CONST Type ConstDeclList SEMI
;

ConstDeclList ::= (ConstDeclarationList) ConstDeclList COMMA ConstDeclElem
				|
				(OneElemConstDeclList) ConstDeclElem
				;
				
ConstDeclElem ::= (NumConstDecl) IDENT:constName EQUAL NUM_CONST:constVal
			|
			(CharConstDecl) IDENT:constName EQUAL CHAR_CONST:constVal
			|
			(BoolConstDecl) IDENT:constName EQUAL BOOL_CONST:constVal
			;	


/* VAR DECL */
VarDecl ::= (VarDecl) Type:varType VarList SEMI;

VarDeclList ::= (VarDeclarationList) VarDeclList VarDecl
			|
			(NoVarDecls) /* epsilon */
			;

VarList ::= (VariableList) VarList COMMA Var
			|
			(OneElemVarList) Var
			;

Var ::= (ArrayDeclaration) IDENT:varName LSQUARE RSQUARE
		|
		(VarDeclaration) IDENT:varName 
		|
		(ErrorVar) error:e {: parser.report_error("Izvrsen oporavak od greske na linji " + eleft + ", pri deklerisanju globalne promenljive", null); :}
		;

			
/* CLASS DECL */
ClassDecl ::= (ClassDecl) CLASS IDENT:name Extends LBRACE VarDeclList ClassMethods RBRACE
;

Extends ::= (ClassExtends) EXTENDS Type
			|
			(NoExtends)
			;
			
ClassMethods ::= (ClassMethodsList) LBRACE MethodDecls RBRACE
			|
			(NoClassMethods)
			;

/* TYPE */
Type ::= (Type) IDENT:typeName;


/* METHOD DECL */
MethodDecls ::= (MethodDeclList) MethodDecls MethodDecl
			|
			(NoMethodDecls)
			;
			
MethodDecl ::= (MethodDeclWithParms) MethodTypeName LPAREN FormPars RPAREN VarDeclList LBRACE StatementList RBRACE
			|
			(MethodDeclNoParms) MethodTypeName LPAREN RPAREN VarDeclList LBRACE StatementList RBRACE
			;
			
MethodTypeName ::= (NonVoidMethod) Type IDENT:name
				|
				(VoidMethod) VOID IDENT:name
;

FormPars ::= (FormParsList) FormPars COMMA Type Var
			|
			(FormParsElem) Type Var
			|
			(FormParsError) error:e {: parser.report_error("Izvrsen oporavak od greske na liniji " + eleft + ", pri deklaraciji formalnog parametra funkcije", null); :}
			;

/* STATEMENTS */ 
StatementList ::= (StmtList) StatementList Statement
			 	| 
			 	(NoStmt) /* epsilon */
			 	;
			 	
Statement ::= (DesignatorStmt) DesignatorStatement /* SEMI moved to DesignatorStmt */
			|
			(IfStmt) IF LPAREN IfCondition RPAREN Statement
			|
			(IfElseStmt) IF LPAREN IfCondition RPAREN Statement ELSE Statement
			|
			(DoWhileStmt) InitDoWhile DO Statement WHILE LPAREN Condition RPAREN SEMI
			|
			(YieldStmt) YIELD Expr SEMI
			|
			(BreakStmt) BREAK SEMI
			|
			(ContinueStmt) CONTINUE SEMI
			|
			(ReturnVoid) RETURN:ret SEMI
			|
			(ReturnStmt) RETURN Expr SEMI
			|
			(ReadStmt) READ LPAREN Designator RPAREN SEMI
			|
			(PrintStmt) PRINT LPAREN Expr RPAREN SEMI
			|
			(PrintConstStmt) PRINT LPAREN Expr COMMA NUM_CONST RPAREN SEMI
			|
			(MoreStmts) LBRACE StatementList RBRACE
			;
			
InitDoWhile ::= (InitDoWhile) ;
			
/* EXPR */
Expr ::= (BasicTerms) Terms
		|
		(NegTerms) MINUS Terms
		|
		(SwitchExpr) InitSwitch SWITCH LPAREN Expr RPAREN LBRACE CaseList DefaultCase RBRACE
		;
		
InitSwitch ::= (InitSwitch) ;
					
CaseList ::= (Cases) CaseList CASE NUM_CONST COLON StatementList
			|
			(NoCase) /* epsilon */
			;
			
DefaultCase ::= (DefaultCase) DEFAULT COLON StatementList
;
		
/* TERM */
Terms ::= (TermList) Terms Addop Term
		|
		(OneTerm) Term
		;
		
Term ::= (FactorList) Term Mulop Factor
		|
		(OneFactor) Factor
		;
		
/* FACTOR */
Factor ::= (DesignatorFactor) Designator
		|
		(DesignatorFactorActPars) FuncDesignator PossibleActPars
		|
		(NumFactor) NUM_CONST
		|
		(CharFactor) CHAR_CONST
		|
		(BoolFactor) BOOL_CONST
		|
		(NewFactor) NEW Type
		|
		(NewFactorArray) NEW Type LSQUARE Expr RSQUARE
		|
		(ExprFactor) LPAREN Expr RPAREN
		;
			
/* DESIGNATOR */

DesignatorStatement ::= (Assignement) Designator Assignop Expr SEMI
					|
					(ErrorAssigning) Designator error:e SEMI 
					{: parser.report_error("Izvrsen oporavak od greske na liniji " + eleft + ", kod konstrukcije iskaza dodele", null); :}
					|
					(DesignatorActPars) FuncDesignator PossibleActPars SEMI
					|
					(Increase) Designator INC SEMI
					|
					(Decrease) Designator DEC SEMI
					;
					
FuncDesignator ::= (FuncDesignator) Designator;
		
Designator ::= (DesignatorJustIdent) IDENT:name
				|
				(DesignatorWithExpr) IDENT:name LSQUARE Expr RSQUARE
;

					
/* ACT PARS */
ActPars ::= (ActParsList) ActPars COMMA Expr
		|
		(OneExpr) Expr
		;
		
PossibleActPars ::= (WithActPars) LPAREN ActPars RPAREN 
					|
					(WithoutActPars) LPAREN RPAREN 
					;
/* "(" [ActPars] ")" */
		

/* CONDITION */
IfCondition ::= (JustCondition) Condition
			|
			(IfError) error:e {:  parser.report_error("Izvrsen oporavak od greske na liniji " + eleft + ", kod logickog izraza unutar if konstrukcije", null); :}
			;

Condition ::= (CondTerms) Condition OR CondTerm
			|
			(OneCondTerm) CondTerm
			;
			
CondTerm ::= (CondFacts) CondTerm AND CondFact
			|
			(OneCondFact) CondFact
			;
			
CondFact ::= (CondFact1Expr) Expr
			|
			(CondFact2Expr) Expr Relop Expr
			;
			
/* OPERATIONS */
Assignop ::= (Assignop) EQUAL
;

Relop ::= (Equal) EQ 
		|
		(NotEqual) NEQ 
		| 
		(GreaterThen) GT 
		|
		(GreaterThenEqual) GTE 
		|
		(LessThen) LT 
		|
		(LessThenEqual) LTE
;

Addop ::= (Plus) PLUS 
		|
		(Minus) MINUS
;

Mulop ::= (Mul) MUL 
		|
		(Div) DIV 
		|
		(Mod) MOD
;

			